    rdi 0
    wr sp
    eint

    isp -1
    rdi 68
    strs 0
    rdi 150

    call mul2_6
    call puthex
    rdi '\n'
    wr io
    brk

    rdi 255
    isp -3
yloop:
    subi 128
    strs 0
    
    rdi 0
xloop:
    strs 1

    # TODO: Actual math goes here...

    # Time to print?
    lds 1
    andi 0b111
    xori 0b111
    zero
    jcz no_print
    # TODO: Actually print the accumulated value
    rdi 0x23
    call puthex

no_print:
    lds 1
    inc 1
    jcz xloop

    lds 0
    addi 128 # We can't combine these because they don't produce the right carry
    inc -1
    ctog
    jcz yloop

    isp 3
    brk

puthex:
    isp -3
    strs 0
    sw dx
    strs 1
    rd dy
    strs 2
    rd dx
    sr
    sr
    sr
    sr
    call puthexhalf
    lds 0
    andi 0x0F
    call puthexhalf
    lds 1
    wr dx
    lds 2
    wr dy
    isp 3
    ja

puthexhalf:
    subi 0xA
    jcz puthex_digit
    addi 'A'
    wr io
    ja
puthex_digit:
    addi 0xA + '0'
    wr io
    ja

mul2_6:
    isp -3
    sw dx
    strs 1
    rd dy
    strs 2
    lds 3
    strs 0
    rd dx
    call mul8_ext
    sl
    wr dx
    lds 0
    slc
    sw dx
    sl
    sw dx
    slc
    wr dy
    lds 1
    wr dx
    lds 2
    sw dy
    isp 3
    ja

mul8_ext:
    isp -2
    sw dx
    strs 0
    rd dy
    strs 1
    lds 2
        # A is in DX, B is in ACC
        # Interrupt-register reuse segment to save memory accesses
    dint
    iset
    wr dx
    rdi 0
    wr dy
    iclr
    wr dy
    rdi -8
mul8_ext_loop:
    sw dy
    sl
    sw dy
    iset
    sw dy
    slc
    sw dy
    sw dx
    sl
    sw dx
    iclr
    jcz mul8_ext_no_add
    sw dy
    add dx
    sw dy
    iset
    sw dy
    acf
    sw dy
    iclr
mul8_ext_no_add:
    inc 1
    jcz mul8_ext_loop
    iset
    rd dy
    strs 2
    iclr
    rd dy
    eint
    sw dy
    lds 0
    wr dx
    lds 1
    sw dy
    isp 2
    ja

@loc ISR
    jri